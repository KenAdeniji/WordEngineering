<!DOCTYPE html><html lang="en"><body><script>
// create the cody object...
var cody = new Object();
// then fill the cody object with properties (using dot notation)
cody.living = true;
cody.age = 33;
cody.gender = 'male';
cody.getGender = function(){return cody.gender;};
console.log(cody); // logs Object {living = true, age = 33, gender = 'male'}
console.log(cody.getGender()); // logs 'male'

var myObject = new Object(); // produces an Object() object
myObject['0'] = 'f';
myObject['1'] = 'o';
myObject['2'] = 'o';
console.log(myObject); // logs Object { 0="f", 1="o", 2="o"}
var myString = new String('foo'); // produces a String() object
console.log(myString); // logs foo { 0="f", 1="o", 2="o"

// define Person constructor function in order to create custom Person() objects later
var Person = function(living, age, gender) {
	this.living = living;
	this.age = age;
	this.gender = gender;
	this.getGender = function() {return this.gender;};
};
// instantiate a Person object and store it in the cody variable
var cody = new Person(true, 33, 'male');
console.log(cody);

var myArray = new Array('foo','bar');
console.log(myArray.constructor);

var myObject = {
 myString: 'string', 
 myNumber: 10, 
 myBoolean: false, 
 myNull: null, 
 myUndefined: undefined
};
console.log(myObject);

// no object is created when producing primitive values, notice no use of the "new" keyword
var primitiveString1 = "foo";
var primitiveString2 = String('foo');
var primitiveNumber1 = 10;
var primitiveNumber2 = Number('10');
var primitiveBoolean1 = true;
var primitiveBoolean2 = Boolean('true');
// confirm the typeof is not object
console.log(typeof primitiveString1, typeof primitiveString2); // logs 'string,string'
console.log(typeof primitiveNumber1, typeof primitiveNumber2); // logs 'number,number,
console.log(typeof primitiveBoolean1, typeof primitiveBoolean2); // logs 'boolean,boolean'
// versus the usage of a constructor and new keyword for creating objects
var myNumber = new Number(23);
var myString = new String('male');
var myBoolean = new Boolean(false);
var myObject = new Object();
var myArray = new Array('foo', 'bar');
var myFunction = new Function("x", "y", "return x * y");
var myDate = new Date();
var myRegExp = new RegExp('\\bt[a-z]+\\b');
var myError = new Error('Crap!');
// logs 'object object object object object function object function object'
console.log(
typeof myNumber,
typeof myString,
typeof myBoolean,
typeof myObject,
typeof myArray,
typeof myFunction, // BE AWARE typeof returns function for all function objects
typeof myDate,
typeof myRegExp, // BE AWARE typeof returns function for RegExp()
typeof myError
);

// user-defined object constructor
var CustomConstructor = function() {this.foo = 'bar';};
// instantiate an instance of CustomConstructor

var instanceOfCustomObject = new CustomConstructor(); 
console.log(instanceOfCustomObject instanceof CustomConstructor); // logs true
// works the same as a native object
console.log(new Array('foo') instanceof Array); // logs true

var myObject = {};
// contain properties inside of myObject representing most of the native JavaScript values
myObject.myFunction = function() {};
myObject.myArray = [];
myObject.myString = 'string';
myObject.myNumber = 33;
myObject.myDate = new Date();
myObject.myRegExp = /a/;
myObject.myNull = null;
myObject.myUndefined = undefined;
myObject.myObject = {};
myObject.myMath_PI = Math.PI;
myObject.myError = new Error('Crap!');
console.log(myObject.myFunction,myObject.myArray,myObject.myString,myObject.myNumber,myObject.myDate,myObject.myRegExp,myObject.myNull,myObject.myNull,myObject.myUndefined,myObject.myObject,myObject.myMath_PI,myObject.myError);

// creating cody Object() object
var cody = new Object();
// setting properties
cody['living'] = true;
cody['age'] = 33; 
cody['gender'] = 'male';
cody['getGender'] = function() {return cody.gender;};
// getting properties
console.log(
cody['living'], 
cody['age'], 
cody['gender'], 
cody['getGender']() // just slap the function invocation on the end!
); // logs 'true 33 male male

var foobarObject = {foobar: 'Foobar is code for no code'};
var string1 = 'foo';
var string2 = 'bar';
console.log(foobarObject[string1 + string2]); // Let's see dot notation do this!

var myObject = {'123':'zero','class':'foo'};
// Let's see dot notation do this! Keep in mind 'class' is a keyword in JavaScript
console.log(myObject['123'], myObject['class']); //logs 'zero foo'

var foo = {bar: 'bar'};
delete foo.bar;
console.log('bar' in foo); // logs false, because bar was deleted from foo

var myObject = {foo: 'value'};
console.log(myObject.hasOwnProperty('foo')) // logs true
// vs. a property from the prototype chain
console.log(myObject.hasOwnProperty('toString')); // logs false

for(var key in cody) { // key is a variable used to represent each property name
	// avoid properties inherited from the prototype chain
	if(cody.hasOwnProperty(key)) {
		console.log(key);
	}
}
</script></body></html>